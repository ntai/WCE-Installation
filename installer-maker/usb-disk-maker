#!/usr/bin/env python

import os, sys, subprocess, string, re, traceback, time, shutil

try:
    import dialog
except:
    print 'python-dialog package is not installed. Try'
    print '  sudo apt-get install ptyhon-dialog'
    sys.exit(1)
    pass

if not os.path.exists("/sbin/install-mbr"):
    subprocess.call("sudo apt-get install mbr", shell=True)
    pass

disk1_re = re.compile(r"Disk /dev/[^:]+:\s+\d+\.{0,1}\d*\s+[KMG]B, (\d+) bytes")
disk2_re = re.compile(r"\d+ heads, \d+ sectors/track, \d+ cylinders, total (\d+) sectors")
disk3_re = re.compile(r"Units = sectors of \d+ * \d+ = (\d+) bytes")
part_re = re.compile(r"([^\s]+)\s+\*{0,1}\s+\d+\s+\d+\s+\d+\s+([\dA-Fa-f]+)\s+")

indentstr = "                                                                                          "

class node:
    def __init__(self, parent, name):
        self.total_size = 0
        self.file_size = 0
        self.parent = parent
        self.files = []
        self.dirs = []
        self.path = None
        self.name = name
        self.destination = None
        pass

    def get_full_path(self):
        if not self.path:
            self.path = os.path.join(self.parent.get_full_path(), self.name)
            pass
        return self.path

    def walk(self):
        path = self.get_full_path()
        for entry in os.listdir(path):
            entry_path = os.path.join(path, entry)
            if os.path.isfile(entry_path):
                self.file_size = self.file_size + os.path.getsize(entry_path)
                self.files.append(entry)
                pass
            elif os.path.isdir(entry_path):
                self.dirs.append(node(self, entry))
                pass
            pass
        for dir in self.dirs:
            dir.walk()
            pass
        pass

    def get_total_file_size(self):
        size = self.file_size
        for dir in self.dirs:
            size = size + dir.file_size
            pass
        return size


    def set_destination(self, destnode, walk):
        if self.destination != None:
            return
        self.destination = destnode
        self.destination.total_size = self.total_size
        self.destination.file_size = self.file_size
        self.destination.files = self.files
        if walk:
            for dir in self.dirs:
                partner = node(destnode, dir.name)
                self.destination.dirs.append(partner)
                dir.set_destination(partner, True)
                pass
            pass
        pass


    def print_plan(self, level):
        print "%s%s -> %s" % (indentstr[0:level*2], self.get_full_path(), self.destination.get_full_path())
        print "%sTotal size: %d" % (indentstr[0:level*2], self.file_size)
        for file in self.files:
            print "%s%s" % (indentstr[0:level*2], file)
            pass
        for dir in self.dirs:
            dir.print_plan(level+1)
            pass
        pass


    def get_destination_path(self, file):
        return os.path.join(self.get_full_path(), file)


    def generate_plan(self):
        plan = []
        src = self.get_full_path()
        dst = self.destination.get_full_path()
        plan.append(('dir', src, dst, 0))
        for file in self.files:
            srcfile = os.path.join(src, file)
            dstfile = self.destination.get_destination_path(file)
            plan.append(('copy', srcfile, dstfile, os.path.getsize(srcfile)))
            pass
        for dir in self.dirs:
            plan = plan + dir.generate_plan()
            pass
        return plan

    pass


class root_node(node):
    def __init__(self, path):
        self.total_size = 0
        self.file_size = 0
        self.parent = None
        self.files = []
        self.dirs = []
        self.path = path
        self.name = None
        self.destination = None
        pass
    

    def get_full_path(self):
        return self.path

    def print_plan(self, level):
        node.print_plan(self, level)
        print "Grand total: %d" % self.get_total_file_size()
        pass

    pass


class syslinux_node(node):
    def __init__(self, parent, name):
        self.total_size = 0
        self.file_size = 0
        self.parent = parent
        self.files = []
        self.dirs = []
        self.path = None
        self.name = name
        self.destination = None
        pass

    def get_destination_path(self, file):
        if file == "isolinux.cfg":
            return os.path.join(self.get_full_path(), "syslinux.cfg")
        elif file == "isolinux.bin":
            return os.path.join(self.get_full_path(), "syslinux.bin")
        return os.path.join(self.get_full_path(), file)

    pass


def make_copy_plan(srcdir, destdir):
    root = root_node(srcdir)
    root.walk()
    destroot = root_node(destdir)
    root.set_destination(destroot, False)
    # need to filter out syslinux?
    has_isolinux = False
    for dir in root.dirs:
        if dir.name == "isolinux":
            has_isolinux = True
            pass
        pass

    dirs = []

    for dir in root.dirs:
        if dir.name == "isolinux" and has_isolinux:
            dir.set_destination(syslinux_node(destroot, "syslinux"), True)
            dirs.append(dir)
        elif dir.name == "syslinux" and has_isolinux:
            continue
        else:
            dir.set_destination(node(destroot, dir.name), True)
            dirs.append(dir)
            pass
        pass
    # dirs holds the dirs without syslinux
    root.dirs = dirs
    return root.generate_plan()


def execute_copy_plan(plan):
    global dlg
    total_cost = 0
    for step in plan:
        if step[0] == 'dir':
            cost = 2
        else:
            cost = (step[3] + 4095) / 4096 + 1 
            pass
        total_cost = total_cost + cost
        pass
    
    dlg.gauge_start("Copying: 0%", title="Copying bootstrap files")
    sofar = 0
    for step in plan:
        percentage = (100 * sofar) / total_cost
        dlg.gauge_update(percentage, "Copying %s" % step[2], update_text=1)
        if step[0] == 'dir':
            cost = 2
            if not os.path.exists(step[2]):
                os.mkdir(step[2])
                pass
            shutil.copymode(step[1], step[2])
        else:
            cost = (step[3] + 4095) / 4096 + 1 
            shutil.copy2(step[1], step[2])
            pass
        sofar = sofar + cost
        percentage = (100 * sofar) / total_cost
        dlg.gauge_update(percentage, "Copying %s" % step[2], update_text=1)
        pass
    dlg.gauge_stop()
    pass


def mount_iso_file(iso_file, iso_mount_point):
    global logfile
    if not os.path.exists(iso_mount_point):
        os.mkdir(iso_mount_point)
        pass
    print >> logfile, "mount -o loop %s %s" % (iso_file, iso_mount_point)
    mount = subprocess.Popen(["mount", "-o", "loop", iso_file, iso_mount_point], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (out, err) = mount.communicate()
    print >> logfile, "mount out: %s" % out
    print >> logfile, "mount err: %s" % err
    pass

def unmount_iso_file(iso_file, iso_mount_point):
    print >> logfile, "umount %s %s" % (iso_file, iso_mount_point)
    umount = subprocess.Popen(["umount", iso_mount_point], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (out, err) = umount.communicate()
    print >> logfile, "umount out: %s" % out
    print >> logfile, "umount err: %s" % err
    os.rmdir(iso_mount_point)
    pass


class partition:
    def __init__(self):
        self.device_name = None
        self.partition_type = None
        self.partition_number = None
        self.partition_name = None
        pass

    def mkfs(self, name):
        global logfile
        mkfs = None
        if self.partition_type == 'c':
            mkfs = subprocess.Popen(["mkfs.vfat", "-F", "32", "-n", name, self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        elif self.partition_type == '83':
            mkfs = subprocess.Popen(["mkfs.ext2", "-b", "4096", "-L", name, self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            pass
        if mkfs:
            (out, err) = mkfs.communicate()
            print >> logfile, "mkfs out: %s" % out
            print >> logfile, "mkfs err: %s" % err
            pass
        self.partition_name = name
        pass


    def unmount(self):
        unmount = subprocess.Popen(["/bin/umount", "-f", self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = unmount.communicate()
        pass

    def get_mount_point(self):
        return "/media/%s" % self.partition_name
    
    def mount(self):
        mount_point = self.get_mount_point()
        if not os.path.exists(mount_point):
            os.mkdir(mount_point)
            pass
        subprocess.call(["/bin/mount", self.device_name, mount_point], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        pass


    def install_bootloader(self):
        global logfile
        print >> logfile, "syslinux to a partition %s" % self.device_name
        syslinux = subprocess.Popen(["/usr/bin/syslinux", "-maf", self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = syslinux.communicate()
        print >> logfile, "syslinux out %s" % out
        print >> logfile, "syslinux err %s" % err
        pass

    pass


class disk:
    def __init__(self):
        self.device_name = None
        self.partitions = []
        self.disk_type = None
        self.size = None
        self.sectors = None
        self.uuid1 = None
        self.uuid2 = None
        self.mounted = False
        self.is_disk = None
        self.is_ata_or_scsi = None
        self.is_usb = None
        self.vendor = ""
        self.model_name = ""
        self.serial_no = ""
        pass


    def get_size(self):
        if self.size:
            return self.size

        fdisk = subprocess.Popen(["fdisk", "-l", "-u", self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = fdisk.communicate()

        for line in out.split("\n"):
            if line == "":
                break
            m = disk1_re.match(line)
            if m:
                self.size = string.atoi(m.group(1))
                break
                pass
            pass
        return self.size


    def start_parted(self):
        size = self.get_size()
        sectors = size / 512

        part1_sectors = (750 * 1024 * 1024) / 512
        part1_start = 2048
        if part1_sectors + part1_start > (sectors / 2):
            part1_sectors = (sectors / 2) - part1_start
            pass
        part1_end = part1_start + part1_sectors - 1
        part2_start = part1_start + part1_sectors
        part2_end = sectors - 1 

        args = ["parted", "-s", self.device_name, "unit", "s", "mklabel", "msdos", "mkpart", "primary", "fat32", "%d" % part1_start, "%d" % part1_end, "mkpart", "primary", "ext2", "%d" % part2_start, "%d" % part2_end, "set", "1", "boot", "on" ]
        return subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


    def refresh_partition(self):
        global dlg
        # Disk to look at
        fdisk = subprocess.Popen(["fdisk", "-l", "-u", self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = fdisk.communicate()
        if len(err) > 0:
            dlg.msgbox(err)
            return

        looking_for_partition = False
        self.partitions = []

        for line in out.split("\n"):
            if looking_for_partition:
                m = part_re.match(line)
                if m:
                    part = partition()
                    part.device_name = m.group(1)
                    part.partition_type = m.group(2)
                    self.partitions.append(part)
                    pass
                pass
            else:
                if line == "":
                    looking_for_partition = True
                    continue
                pass
            pass
        pass


    def unmount(self):
        for part in self.partitions:
            part.unmount()
            pass
        pass


    def mount(self):
        for part in self.partitions:
            part.mount()
            pass
        pass


    def find_partition(self, part_name):
        for part in self.partitions:
            if part.device_name == part_name:
                return part
            pass
        return None


    def install_mbr(self):
        global logfile
        print >> logfile, "Install MBR to disk %s" % self.device_name
        mbr = subprocess.Popen(["/sbin/install-mbr", "-f", "-r", self.device_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = mbr.communicate()
        print >> logfile, "install-mbr out %s" % out
        print >> logfile, "install-mbr err %s" % err
        pass

    pass


#
def find_disk_device_files(devpath):
    result = []
    for letter in "abcdefghijklmnopqrstuvwxyz":
        device_file = devpath + letter
        if os.path.exists(device_file):
            result.append(device_file)
        else:
            break
        pass
    return result

# Get USB drives
def get_usb_disks():
    usb_disks = []

    # Gather up the possible disks
    possible_disks = find_disk_device_files("/dev/hd") + find_disk_device_files("/dev/sd")
    
    for disk_name in possible_disks:
        #
        # Now, I do double check that this is really a disk
        is_ata_or_scsi = False
        is_disk = False
        is_usb = False
        disk_model = None
        disk_serial = None
        disk_vendor = None

        try:
            udevadm = subprocess.Popen("udevadm info --query=property --name=%s" % disk_name, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (out, err) = udevadm.communicate()
            if len(err) > 0:
                print err
                pass
            is_ata_or_scsi = False
            is_disk = False
            for line in out.split("\n"):
                try:
                    elems = line.split('=')
                    if len(elems) != 2:
                        continue
                    tag = string.strip(elems[0])
                    value = string.strip(elems[1])
                    if tag == "ID_BUS":
                        if value.lower() == "ata" or value.lower() == "scsi":
                            is_ata_or_scsi = True
                            pass
                        elif value.lower() == "usb":
                            is_usb = True
                            print "USB"
                            pass
                        pass
                    elif tag == "ID_TYPE":
                        if value.lower() == "disk":
                            is_disk = True
                            pass
                        pass
                    elif tag == "ID_MODEL":
                        disk_model = value
                        pass
                    elif tag == "ID_VENDOR":
                        disk_vendor = value
                        pass
                    elif tag == "ID_SERIAL":
                        disk_serial = value
                        pass
                    pass
                except Exception, e:
                    traceback.print_tb(None)
                    raise e
                    pass
                pass
            pass
        except Exception, e:
            traceback.print_tb(None)
            raise e
            pass

        if not is_disk:
            print "Passed on %s" % disk_name
            continue

        # Disk to look at
        current_disk = None
        fdisk = subprocess.Popen(["fdisk", "-l", "-u", disk_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (out, err) = fdisk.communicate()

        looking_for_partition = False

        for line in out.split("\n"):
            if looking_for_partition and current_disk:
                m = part_re.match(line)
                if m:
                    if current_disk:
                        part = partition()
                        part.device_name = m.group(1)
                        part.partition_type = m.group(2)
                        current_disk.partitions.append(part)
                        pass
                    pass
                pass
            else:
                if line == "" and current_disk:
                    looking_for_partition = True
                    continue
                m = disk1_re.match(line)
                if m:
                    current_disk = disk()
                    current_disk.device_name = disk_name
                    current_disk.size = string.atoi(m.group(1))
                    pass
                pass
            pass

        if current_disk:
            current_disk.is_ata_or_scsi = is_ata_or_scsi
            current_disk.is_usb = is_usb
            current_disk.is_disk = is_disk
            current_disk.model_name = disk_model
            current_disk.serial_no = disk_serial

            if is_usb:
                current_disk.get_size()
                usb_disks.append(current_disk)
                pass
            pass
        pass

    return usb_disks


def usb_writer(fresh, mbr, iso_file):
    usb_disks = get_usb_disks()
    if len(usb_disks) == 0:
        print "Did not find any USB disks."
        # dlg.msgbox("Did not find any USB disks.")
        return
    
    menu = []
    for disk in usb_disks:
        menu.append((disk.device_name, "%s %dMB" % (disk.model_name, disk.get_size()/1000000), 0))
        pass

    if fresh:
        prompt = "Existing contents will be destroyed!"
    else:
        prompt = "Updating payload"
        pass

    (code, tag) = dlg.checklist(text=prompt,
                                height=15, width=70, list_height=8, 
                                choices = menu, title="USB Disk Maker", 
                                backtitle="World Computer Exchange")

    # code == 1: cancel
    if code == 1 or len(tag) == 0:
        return

    iso_mount_point = "/mnt/my_iso.%d" % os.getpid()
    mount_iso_file(iso_file, iso_mount_point)

    for disk in usb_disks:
        if not (disk.device_name in tag):
            continue
        #
        disk.unmount()
        #
        if fresh:
            parted = disk.start_parted()
            (out, err) = parted.communicate()
            if len(err) > 0:
                dlg.msgbox("parted error\n" + err)
                continue
            disk.refresh_partition()
            disk.unmount()
            pass

        boot_part = None
        ext2_part = None
        for part in disk.partitions:
            if fresh:
                dlg.infobox( "Formatting %s" % part.device_name)
                pass
            if part.partition_type == 'c':
                boot_part = part
                if fresh:
                    part.mkfs("ubuntu")
                else:
                    part.partition_name = "ubuntu"
                    pass
            elif part.partition_type == '83':
                ext2_part = part
                if fresh:
                    part.mkfs("casper-rw")
                else:
                    part.partition_name = "casper-rw"
                    pass
                pass
            pass

        if fresh:
            dlg.infobox( "Formatting complete")
            pass

        disk.mount()
        dlg.infobox( "Figuring out copying")
        plan = make_copy_plan(iso_mount_point, boot_part.get_mount_point())
        print >> logfile, "===== COPY PLAN ====="
        print >> logfile, plan
        print >> logfile, "====================="
        execute_copy_plan(plan)
        dlg.infobox( "Finished copying")
        disk.unmount()

        if mbr:
            dlg.infobox( "Installing bootloader to %s" % boot_part.device_name)
            boot_part.install_bootloader()

            dlg.infobox( "Installing MBR to %s" % disk.device_name)
            disk.install_mbr()
            pass
        pass

    dlg.infobox( "Unmounting ISO")
    unmount_iso_file(iso_file, iso_mount_point)

    pass


try:
    import pygtk
    import gtk
except:
    pass


class gui_writer():
    ui = '''<ui>
    <menubar name="MenuBar">
      <menu action="File">
        <menuitem action="Choose"/>
        <menuitem action="Refresh"/>
        <menuitem action="Install"/>
        <menuitem action="Quit"/>
      </menu>
    </menubar>

    <toolbar name="Toolbar">
      <toolitem action="Choose"/>
      <toolitem action="Refresh"/>
      <toolitem action="Install"/>
      <toolitem action="Quit"/>
      <separator/>
    </toolbar>

    </ui>'''
      
    def __init__(self):
        #
        self.image_file = None

        # Create the toplevel window
        self.window = gtk.Window()
        self.window.connect('destroy', lambda w: gtk.main_quit())
        self.window.set_size_request(500, -1)
        vbox = gtk.VBox()
        self.window.add(vbox)

        # Create a UIManager instance
        uimanager = gtk.UIManager()
        self.uimanager = uimanager

        # Add the accelerator group to the toplevel window
        accelgroup = uimanager.get_accel_group()
        self.window.add_accel_group(accelgroup)

        # Create an ActionGroup
        actiongroup = gtk.ActionGroup('DiskImageInstaller')
        self.actiongroup = actiongroup

        # Create actions
        actiongroup.add_actions([('Quit', gtk.STOCK_QUIT, '_Quit', None, 'Quit the Program', self.quit_cb),
                                 ('File', None, '_File')])
        actiongroup.add_actions([('Choose', gtk.STOCK_OPEN, '_Choose image...', None, 'Choose disk image file', self.choose_image_file_cb),
                                 ('Install', gtk.STOCK_APPLY, '_Install', None, 'Install', self.install_cb),
                                 ('Refresh', gtk.STOCK_REFRESH, '_Refresh', None, 'Refresh disk status', self.refresh_disks_cb)])
        actiongroup.get_action('Quit').set_property('short-label', '_Quit')

        # Add the actiongroup to the uimanager
        uimanager.insert_action_group(actiongroup, 0)

        # Add a UI description
        uimanager.add_ui_from_string(self.ui)

        # Create a MenuBar
        menubar = uimanager.get_widget('/MenuBar')
        vbox.pack_start(menubar, False)

        # Create a Toolbar
        toolbar = uimanager.get_widget('/Toolbar')
        vbox.pack_start(toolbar, False)

        # Create the image file
        self.image_file_label = gtk.Label('Image file:')
        self.image_file_label.set_alignment(0, 0.5)
        vbox.pack_start(self.image_file_label)

        disks_label = gtk.Label('Disks')
        disks_label.set_alignment(0.5, 1.0)
        vbox.pack_start(disks_label)

        buttonbox = gtk.HButtonBox()
        self.disk_buttons = []
        
        for name in ["sda", "sdb", "sdc", "sdd", "sde", "sdf", "sdg", "sdh", "sdi", "sdj" ]:
            disk_button = gtk.CheckButton(name)
            self.disk_buttons.append(disk_button)
            disk_button.set_active(True)
            disk_button.connect('toggled', self.toggle_disk)
            buttonbox.pack_start(disk_button, False)
            pass

        vbox.pack_start(buttonbox)

        
        liststore = gtk.ListStore(str, str, int)
        liststore.append(["Partitioning", "", 0])
        liststore.append(["Imaging",      "", 0])
        liststore.append(["Finalizing",   "", 0])
        self.progress_table = liststore

        treeview = gtk.TreeView(liststore)
        
        column_phase = gtk.TreeViewColumn("Activity")
        treeview.append_column(column_phase)

        column_status = gtk.TreeViewColumn("Status")
        treeview.append_column(column_status)

        column_progress = gtk.TreeViewColumn("Progress")
        treeview.append_column(column_progress)

        cell_phase_renderer = gtk.CellRendererText()
        column_phase.pack_start(cell_phase_renderer, False)
        column_phase.add_attribute(cell_phase_renderer, "text", 0)
        
        cell_status_renderer = gtk.CellRendererText()
        column_status.pack_start(cell_status_renderer, False)
        column_status.add_attribute(cell_status_renderer, "text", 1)

        cell_progress_renderer = gtk.CellRendererProgress()
        column_progress.pack_start(cell_progress_renderer, True)
        column_progress.add_attribute(cell_progress_renderer, "value", 2)

        vbox.pack_start(treeview)

        self.window.show_all()

        self.refresh_disks()
        return

    def toggle_disk(self, action):
        # action has not toggled yet
        return

    def quit_cb(self, b):
        gtk.main_quit()
        pass

    def choose_image_file_cb(self, b):
        self.choose_image_file()
        pass

    def choose_image_file(self):
        chooser = gtk.FileChooserDialog(parent=self.window,
                                        title="Choose WCE Disk Image File",
                                        action=gtk.FILE_CHOOSER_ACTION_OPEN,
                                        buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        chooser.set_current_folder("/var/www/wce-disk-images")

        response = chooser.run()
        if response == gtk.RESPONSE_OK:
            self.image_file = chooser.get_filename()
            self.image_file_label.set_text("Image file: %s" % self.image_file)
            pass
        chooser.destroy()
        pass

    def clear_status(self):
        for row in range(0, 3):
            which = self.progress_table.get_iter(row)
            self.progress_table.set(which, 1, "")
            self.progress_table.set(which, 2, 0)
            pass
        while gtk.events_pending():
            gtk.main_iteration()
            pass
        pass


    def refresh_disks_cb(self, b):
        self.clear_status()
        self.refresh_disks()
        pass

    def refresh_disks(self):
        global mounted_devices, mounted_partitions
        disks, usb_disks = get_disks(True, False)

        all_disks = disks + usb_disks
        table = {}
        for disk in all_disks:
            table[disk.device_name] = 1
            pass

        for disk_button in self.disk_buttons:
            disk_name = "/dev/%s" % disk_button.get_label()
            if table.has_key(disk_name):
                disk_button.set_sensitive(True)
                if mounted_devices.has_key(disk_name):
                    disk_button.set_active(False)
                else:
                    disk_button.set_active(True)
                    pass
            else:
                disk_button.set_active(False)
                disk_button.set_sensitive(False)
                pass
            pass

        pass

    def install_cb(self, b):
        self.start_installation()
        pass

    def start_installation(self):
        self.progress_table
        if not self.image_file:
            self.choose_image_file()
            if not self.image_file:
                return
            pass

        install_button = self.uimanager.get_widget('/Toolbar/Install')
        install_button.set_sensitive(False)

        for disk_button in self.disk_buttons:
            disk_name = "/dev/%s" % disk_button.get_label()
            if disk_button.get_active() and disk_button.get_sensitive():
                self.install_image(disk_name)
                disk_button.set_active(False)
                pass
            pass

        install_button.set_sensitive(True)
        pass


    def install_image(self, disk_name):
        cmdline = "%s --install %s --target-disk %s" % (sys.argv[0], self.image_file, disk_name )
        cmd_args = shlex.split(cmdline)
        backend = subprocess.Popen(cmd_args, bufsize=1, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        read_set = [backend.stdout, backend.stderr]
        write_set = []
        progress_re = re.compile(r'(\d\d\d) (.*)')
        stderr_data = ""
        stdout_data = ""
        rlist = []

        while backend.poll() == None:
            try:
                rlist, wlist, xlist = select.select(read_set, write_set, [], 0.5)
            except select.error, e:
                if e.args[0] == errno.EINTR:
                    continue
                raise

            if backend.stderr in rlist:
                data = os.read(backend.stderr.fileno(), 1024)
                if data == "":
                    read_set.remove(backend.stderr)
                    pass
                else:
                    pass
                pass

            if backend.stdout in rlist:
                data = os.read(backend.stdout.fileno(), 1024)
                if data == "":
                    read_set.remove(backend.stdout)
                    pass
                else:
                    sys.stdout.write(data)
                    stdout_data = stdout_data + data
                    lines = stdout_data.split('\n')
                    stdout_data = lines[-1]
                    lines = lines[:-1]
                    for line in lines:
                        m = progress_re.match(line)
                        if m:
                            progress = string.atof(m.group(1))
                            if progress < 20:
                                progress_min = 0
                                progress_max = 19
                                row = 0
                                pass
                            elif progress < 90:
                                progress_min = 20
                                progress_max = 89
                                row = 1
                                pass
                            elif progress <= 100:
                                progress_min = 90
                                progress_max = 100
                                row = 2
                                pass
                            elif progress > 900:
                                row = 2
                                pass

                            which = self.progress_table.get_iter(row)
                            self.progress_table.set(which, 1, m.group(2))
                            if progress >= 900:
                                self.progress_table.set(which, 2, 0)
                            else:
                                self.progress_table.set(which, 2, (100*(progress - progress_min)) / (progress_max - progress_min))
                                pass
                            if progress >= 100:
                                break
                            pass
                        pass
                    pass
                pass

            while gtk.events_pending():
                gtk.main_iteration()
                pass

            pass
        pass
    pass



def main(fresh, mbr, iso_file):
    if os.getuid() == 0:
        usb_writer(fresh, mbr, iso_file)
        pass
    else:
        # Rerun the script with sudo
        subprocess.call("gksudo -- python %s" % sys.argv[0], shell=True)
        pass
    pass


if __name__ == "__main__":
    global dlg, iso_file, logfile
    logfile = open("log.txt", "w")

    dlg = dialog.Dialog()
    iso_file = None

    fresh = True
    mbr = True
    argv = sys.argv[1:]
    if len(argv) > 0:
        if argv[0] == "-update":
            fresh = False
            mbr = False
            argv = argv[1:]
            pass
        pass

    if len(argv) > 0:
        iso_file = argv[0]
        pass
    else:
        (code, iso_file) = dlg.fselect(os.getcwd(), 20, 76)
        if code != 0:
            dlg.infobox("No ISO selected.")
            sys.exit(0)
            pass
        pass

    if not os.path.exists(iso_file):
        dlg.infobox("ISO file %s does not exist." % iso_file)
        sys.exit(0)
        pass

    main(fresh, mbr, iso_file)
    pass
